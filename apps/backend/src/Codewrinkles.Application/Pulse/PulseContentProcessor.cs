using System.Text.RegularExpressions;
using Codewrinkles.Application.Common.Interfaces;
using Codewrinkles.Domain.Pulse;

namespace Codewrinkles.Application.Pulse;

/// <summary>
/// Result of mention processing containing count and list of mentioned profiles.
/// </summary>
public sealed record MentionProcessingResult(
    int Count,
    IReadOnlyList<Domain.Identity.Profile> MentionedProfiles
);

/// <summary>
/// Application service for processing pulse content (hashtags and mentions).
/// Handles extraction and persistence of content metadata.
/// </summary>
public sealed class PulseContentProcessor
{
    // Regex patterns as static readonly (compiled for performance)
    private static readonly Regex MentionPattern = new(
        @"@(\w{3,30})",
        RegexOptions.Compiled);

    private static readonly Regex HashtagPattern = new(
        @"#(\w{2,100})",
        RegexOptions.Compiled);

    private readonly IUnitOfWork _unitOfWork;
    private readonly IProfileRepository _profileRepository;

    public PulseContentProcessor(
        IUnitOfWork unitOfWork,
        IProfileRepository profileRepository)
    {
        _unitOfWork = unitOfWork;
        _profileRepository = profileRepository;
    }

    /// <summary>
    /// Extracts @mentions from pulse content.
    /// </summary>
    /// <param name="content">The pulse content to extract mentions from.</param>
    /// <returns>List of handles (lowercase, without @ prefix).</returns>
    public List<string> ExtractMentions(string content)
    {
        // Regex to match @handle (alphanumeric + underscore, 3-30 chars)
        var matches = MentionPattern.Matches(content);

        return matches
            .Select(m => m.Groups[1].Value.ToLowerInvariant())
            .Distinct()
            .ToList();
    }

    /// <summary>
    /// Extracts #hashtags from pulse content.
    /// </summary>
    /// <param name="content">The pulse content to extract hashtags from.</param>
    /// <returns>List of (original display text, position in content).</returns>
    public List<(string TagDisplay, int Position)> ExtractHashtags(string content)
    {
        // Regex to match #hashtag (alphanumeric + underscore, 2-100 chars)
        var matches = HashtagPattern.Matches(content);

        var hashtagsWithPositions = new List<(string, int)>();
        var seenTags = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        for (var i = 0; i < matches.Count; i++)
        {
            var tagDisplay = matches[i].Groups[1].Value;
            var normalizedTag = tagDisplay.ToLowerInvariant();

            // Track unique hashtags (case-insensitive)
            // If #coding and #Coding both appear, only count the first one
            if (seenTags.Add(normalizedTag))
            {
                hashtagsWithPositions.Add((tagDisplay, i));
            }
        }

        return hashtagsWithPositions;
    }

    /// <summary>
    /// Processes hashtags for a pulse:
    /// - Finds or creates Hashtag entities
    /// - Increments usage counts
    /// - Creates PulseHashtag associations
    /// </summary>
    /// <param name="pulseId">The pulse ID to associate hashtags with.</param>
    /// <param name="content">The pulse content to extract hashtags from.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Total hashtag count processed.</returns>
    public async Task<int> ProcessHashtagsAsync(
        Guid pulseId,
        string content,
        CancellationToken cancellationToken = default)
    {
        var hashtagsWithPositions = ExtractHashtags(content);

        if (hashtagsWithPositions.Count == 0)
        {
            return 0;
        }

        foreach (var (tagDisplay, position) in hashtagsWithPositions)
        {
            // Try to find existing hashtag by normalized tag
            var normalizedTag = tagDisplay.ToLowerInvariant();
            var existingHashtag = await _unitOfWork.Hashtags.FindByTagAsync(
                normalizedTag,
                cancellationToken);

            Hashtag hashtag;
            if (existingHashtag is not null)
            {
                // Hashtag exists - increment usage
                existingHashtag.IncrementUsage();
                hashtag = existingHashtag;
            }
            else
            {
                // New hashtag - create it
                hashtag = Hashtag.Create(tagDisplay);
                hashtag.IncrementUsage(); // Increment for the current pulse
                _unitOfWork.Hashtags.CreateHashtag(hashtag);
                await _unitOfWork.SaveChangesAsync(cancellationToken);
                // Hashtag.Id is now available (generated by EF Core)
            }

            // Create pulse-hashtag association
            var pulseHashtag = PulseHashtag.Create(
                pulseId: pulseId,
                hashtagId: hashtag.Id,
                position: position);
            _unitOfWork.Hashtags.CreatePulseHashtag(pulseHashtag);
        }

        await _unitOfWork.SaveChangesAsync(cancellationToken);
        return hashtagsWithPositions.Count;
    }

    /// <summary>
    /// Processes mentions for a pulse:
    /// - Finds mentioned profiles by handle
    /// - Creates PulseMention entities
    /// </summary>
    /// <param name="pulseId">The pulse ID to associate mentions with.</param>
    /// <param name="content">The pulse content to extract mentions from.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Result containing count and list of mentioned profiles (caller responsible for creating notifications).</returns>
    public async Task<MentionProcessingResult> ProcessMentionsAsync(
        Guid pulseId,
        string content,
        CancellationToken cancellationToken = default)
    {
        var mentionedHandles = ExtractMentions(content);

        if (mentionedHandles.Count == 0)
        {
            return new MentionProcessingResult(0, Array.Empty<Domain.Identity.Profile>());
        }

        var mentionedProfiles = await _profileRepository.FindByHandlesAsync(
            mentionedHandles,
            cancellationToken);

        foreach (var profile in mentionedProfiles)
        {
            var mention = PulseMention.Create(pulseId, profile.Id, profile.Handle!);
            _unitOfWork.Pulses.CreateMention(mention);
        }

        await _unitOfWork.SaveChangesAsync(cancellationToken);

        return new MentionProcessingResult(mentionedProfiles.Count, mentionedProfiles);
    }
}
