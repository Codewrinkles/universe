using System.Data;
using System.Text.RegularExpressions;
using Kommand.Abstractions;
using Codewrinkles.Application.Common.Interfaces;
using Codewrinkles.Domain.Pulse;
using Codewrinkles.Telemetry;

namespace Codewrinkles.Application.Pulse;

public sealed record CreatePulseCommand(
    Guid AuthorId,
    string Content,
    Stream? ImageStream = null
) : ICommand<CreatePulseResult>;

public sealed record CreatePulseResult(
    Guid PulseId,
    string Content,
    DateTime CreatedAt,
    string? ImageUrl = null
);

public sealed class CreatePulseCommandHandler
    : ICommandHandler<CreatePulseCommand, CreatePulseResult>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IPulseImageService _pulseImageService;
    private readonly IProfileRepository _profileRepository;
    private readonly ILinkPreviewService _linkPreviewService;

    public CreatePulseCommandHandler(
        IUnitOfWork unitOfWork,
        IPulseImageService pulseImageService,
        IProfileRepository profileRepository,
        ILinkPreviewService linkPreviewService)
    {
        _unitOfWork = unitOfWork;
        _pulseImageService = pulseImageService;
        _profileRepository = profileRepository;
        _linkPreviewService = linkPreviewService;
    }

    public async Task<CreatePulseResult> HandleAsync(
        CreatePulseCommand command,
        CancellationToken cancellationToken)
    {
        using var activity = TelemetryExtensions.StartApplicationActivity(SpanNames.Pulse.Create);
        activity?.SetProfileId(command.AuthorId);

        try
        {
            // Create Pulse entity (ID will be generated by EF Core during SaveChanges)
            var pulse = Domain.Pulse.Pulse.Create(
                authorId: command.AuthorId,
                content: command.Content);

            string? imageUrl = null;
            var hasImage = command.ImageStream is not null;
            var mentionCount = 0;
            var hashtagCount = 0;
            var hasLink = false;

            // Perform all database operations atomically within a transaction
            // Isolation Level: ReadCommitted
            // - Prevents dirty reads (other transactions won't see incomplete Pulse without Engagement)
            // - No unnecessary locking (we're only doing inserts, no reads)
            await using var transaction = await _unitOfWork.BeginTransactionAsync(
                IsolationLevel.ReadCommitted,
                cancellationToken);
            try
            {
                // 1. Create Pulse
                _unitOfWork.Pulses.Create(pulse);
                await _unitOfWork.SaveChangesAsync(cancellationToken);
                // Pulse.Id is now available (generated by EF Core sequential GUID)

                activity?.SetEntity("Pulse", pulse.Id);

                // 2. Process and save image to disk (if provided)
                // This is a file I/O operation, not a database operation
                // If it fails, we'll rollback the transaction and clean up the file in catch block
                if (command.ImageStream is not null)
                {
                    var (url, width, height) = await _pulseImageService.SavePulseImageAsync(
                        command.ImageStream,
                        pulse.Id,
                        cancellationToken);

                    var pulseImage = PulseImage.Create(
                        pulseId: pulse.Id,
                        url: url,
                        width: width,
                        height: height);

                    _unitOfWork.Pulses.CreateImage(pulseImage);
                    await _unitOfWork.SaveChangesAsync(cancellationToken);

                    imageUrl = url;
                    AppMetrics.RecordImageUpload(imageType: "pulse", success: true);
                }

                // 3. Create PulseEngagement with zero counts
                // This is REQUIRED - Pulse.Engagement relationship is configured as .IsRequired()
                // Without this, any query loading Pulse will fail with missing required navigation
                var engagement = PulseEngagement.Create(pulse.Id);
                _unitOfWork.Pulses.CreateEngagement(engagement);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                // 4. Extract and create mentions
                var mentionedHandles = ExtractMentions(pulse.Content);
                if (mentionedHandles.Count > 0)
                {
                    var mentionedProfiles = await _profileRepository.FindByHandlesAsync(mentionedHandles, cancellationToken);
                    foreach (var profile in mentionedProfiles)
                    {
                        var mention = PulseMention.Create(pulse.Id, profile.Id, profile.Handle!);
                        _unitOfWork.Pulses.CreateMention(mention);

                        // Create mention notification (only if not mentioning self)
                        if (profile.Id != command.AuthorId)
                        {
                            var mentionNotification = Domain.Notification.Notification.CreateMentionNotification(
                                recipientId: profile.Id,
                                actorId: command.AuthorId,
                                pulseId: pulse.Id);
                            _unitOfWork.Notifications.Create(mentionNotification);
                            AppMetrics.RecordNotificationCreated("mention");
                        }
                    }
                    await _unitOfWork.SaveChangesAsync(cancellationToken);
                    mentionCount = mentionedProfiles.Count;
                }

                // 5. Generate link preview if URL detected
                var firstUrl = _linkPreviewService.ExtractFirstUrl(pulse.Content);
                if (firstUrl is not null)
                {
                    hasLink = true;
                    var previewData = await _linkPreviewService.FetchPreviewAsync(
                        firstUrl,
                        cancellationToken);

                    if (previewData is not null)
                    {
                        var linkPreview = PulseLinkPreview.Create(
                            pulseId: pulse.Id,
                            url: previewData.Url,
                            title: previewData.Title,
                            domain: previewData.Domain,
                            description: previewData.Description,
                            imageUrl: previewData.ImageUrl);

                        _unitOfWork.Pulses.CreateLinkPreview(linkPreview);
                        await _unitOfWork.SaveChangesAsync(cancellationToken);
                        AppMetrics.RecordLinkPreviewFetch(success: true);
                    }
                    else
                    {
                        AppMetrics.RecordLinkPreviewFetch(success: false);
                    }
                }

                // 6. Extract and process hashtags
                var hashtagsWithPositions = ExtractHashtags(pulse.Content);
                if (hashtagsWithPositions.Count > 0)
                {
                    foreach (var (tagDisplay, position) in hashtagsWithPositions)
                    {
                        // Try to find existing hashtag by normalized tag
                        var normalizedTag = tagDisplay.ToLowerInvariant();
                        var existingHashtag = await _unitOfWork.Hashtags.FindByTagAsync(
                            normalizedTag,
                            cancellationToken);

                        Hashtag hashtag;
                        if (existingHashtag is not null)
                        {
                            // Hashtag exists - increment usage
                            existingHashtag.IncrementUsage();
                            hashtag = existingHashtag;
                        }
                        else
                        {
                            // New hashtag - create it
                            hashtag = Hashtag.Create(tagDisplay);
                            hashtag.IncrementUsage(); // Increment for the current pulse
                            _unitOfWork.Hashtags.CreateHashtag(hashtag);
                            await _unitOfWork.SaveChangesAsync(cancellationToken);
                            // Hashtag.Id is now available (generated by EF Core)
                        }

                        // Create pulse-hashtag association
                        var pulseHashtag = PulseHashtag.Create(
                            pulseId: pulse.Id,
                            hashtagId: hashtag.Id,
                            position: position);
                        _unitOfWork.Hashtags.CreatePulseHashtag(pulseHashtag);
                    }

                    await _unitOfWork.SaveChangesAsync(cancellationToken);
                    hashtagCount = hashtagsWithPositions.Count;
                }

                // Commit transaction - all entities created successfully
                // Database state is now consistent: Pulse + Engagement + (optional) PulseImage + (optional) Mentions + (optional) Hashtags
                await transaction.CommitAsync(cancellationToken);
            }
            catch
            {
                // Rollback on any error - no database records will be persisted
                await transaction.RollbackAsync(cancellationToken);

                // Clean up orphaned image file if it was saved to disk
                // The file I/O isn't part of the database transaction, so we must clean up manually
                if (imageUrl is not null)
                {
                    _pulseImageService.DeletePulseImage(pulse.Id);
                }

                throw;
            }

            // Record metrics and set span metadata
            AppMetrics.RecordPulseCreated(pulseType: "original", hasImage: hasImage);
            activity?.SetPulseMetadata(
                pulseType: "original",
                hasImage: hasImage,
                hasLink: hasLink,
                mentionCount: mentionCount,
                hashtagCount: hashtagCount);
            activity?.SetSuccess(true);

            return new CreatePulseResult(
                PulseId: pulse.Id,
                Content: pulse.Content,
                CreatedAt: pulse.CreatedAt,
                ImageUrl: imageUrl
            );
        }
        catch (Exception ex)
        {
            activity?.RecordError(ex);
            throw;
        }
    }

    private static List<string> ExtractMentions(string content)
    {
        // Regex to match @handle (alphanumeric + underscore, 3-30 chars)
        var mentionPattern = @"@(\w{3,30})";
        var matches = Regex.Matches(content, mentionPattern);

        return matches
            .Select(m => m.Groups[1].Value.ToLowerInvariant())
            .Distinct()
            .ToList();
    }

    private static List<(string TagDisplay, int Position)> ExtractHashtags(string content)
    {
        // Regex to match #hashtag (alphanumeric + underscore, 2-100 chars)
        // Match pattern: # followed by word characters
        var hashtagPattern = @"#(\w{2,100})";
        var matches = Regex.Matches(content, hashtagPattern);

        var hashtagsWithPositions = new List<(string, int)>();
        var seenTags = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        for (var i = 0; i < matches.Count; i++)
        {
            var tagDisplay = matches[i].Groups[1].Value;
            var normalizedTag = tagDisplay.ToLowerInvariant();

            // Track unique hashtags (case-insensitive)
            // If #coding and #Coding both appear, only count the first one
            if (seenTags.Add(normalizedTag))
            {
                hashtagsWithPositions.Add((tagDisplay, i));
            }
        }

        return hashtagsWithPositions;
    }
}
