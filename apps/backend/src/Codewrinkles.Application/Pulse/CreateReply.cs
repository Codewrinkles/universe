using System.Data;
using Kommand.Abstractions;
using Codewrinkles.Application.Common.Interfaces;
using Codewrinkles.Domain.Pulse;
using Codewrinkles.Telemetry;

namespace Codewrinkles.Application.Pulse;

public sealed record CreateReplyCommand(
    Guid AuthorId,
    Guid ParentPulseId,
    string Content,
    Stream? ImageStream = null
) : ICommand<CreatePulseResult>;

public sealed class CreateReplyCommandHandler
    : ICommandHandler<CreateReplyCommand, CreatePulseResult>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IBlobStorageService _blobStorageService;
    private readonly IProfileRepository _profileRepository;
    private readonly PulseContentProcessor _contentProcessor;

    public CreateReplyCommandHandler(
        IUnitOfWork unitOfWork,
        IBlobStorageService blobStorageService,
        IProfileRepository profileRepository,
        PulseContentProcessor contentProcessor)
    {
        _unitOfWork = unitOfWork;
        _blobStorageService = blobStorageService;
        _profileRepository = profileRepository;
        _contentProcessor = contentProcessor;
    }

    public async Task<CreatePulseResult> HandleAsync(
        CreateReplyCommand command,
        CancellationToken cancellationToken)
    {
        using var activity = TelemetryExtensions.StartApplicationActivity(SpanNames.Pulse.Reply);
        activity?.SetProfileId(command.AuthorId);
        activity?.SetTag(TagNames.Pulse.ParentPulseId, command.ParentPulseId.ToString());

        try
        {
            // Fetch parent pulse to determine thread root
            var parentPulse = await _unitOfWork.Pulses.FindByIdAsync(command.ParentPulseId, cancellationToken);

            // Determine thread root:
            // - If replying to Original/Repulse: thread root is the parent itself
            // - If replying to a Reply: inherit the parent's thread root
            //   (for legacy replies without ThreadRootId, fall back to ParentPulseId)
            Guid threadRootId;
            if (parentPulse!.Type == PulseType.Reply)
            {
                // Parent is a reply - use its thread root, or fall back to its parent for legacy data
                threadRootId = parentPulse.ThreadRootId ?? parentPulse.ParentPulseId!.Value;
            }
            else
            {
                // Parent is Original or Repulse - it IS the thread root
                threadRootId = parentPulse.Id;
            }

            // Create Reply entity (ID will be generated by EF Core during SaveChanges)
            var reply = Domain.Pulse.Pulse.CreateReply(
                authorId: command.AuthorId,
                content: command.Content,
                parentPulseId: command.ParentPulseId,
                threadRootId: threadRootId);

            string? imageUrl = null;
            var hasImage = command.ImageStream is not null;
            var hashtagCount = 0;
            MentionProcessingResult mentionResult;

            // Perform all database operations atomically within a transaction
            // Isolation Level: ReadCommitted
            // - Prevents dirty reads (other transactions won't see incomplete Reply without Engagement)
            // - No unnecessary locking (we're only doing inserts and single update)
            await using var transaction = await _unitOfWork.BeginTransactionAsync(
                IsolationLevel.ReadCommitted,
                cancellationToken);
            try
            {
                // 1. Create Reply pulse
                _unitOfWork.Pulses.Create(reply);
                await _unitOfWork.SaveChangesAsync(cancellationToken);
                // Reply.Id is now available (generated by EF Core sequential GUID)

                activity?.SetEntity("Pulse", reply.Id);

                // 2. Process and save image to blob storage (if provided)
                // Upload to Azure Blob Storage - if it fails, we'll rollback and clean up the blob
                if (command.ImageStream is not null)
                {
                    var (url, width, height) = await _blobStorageService.UploadPulseImageAsync(
                        command.ImageStream,
                        reply.Id,
                        cancellationToken);

                    var pulseImage = PulseImage.Create(
                        pulseId: reply.Id,
                        url: url,
                        width: width,
                        height: height);

                    _unitOfWork.Pulses.CreateImage(pulseImage);
                    await _unitOfWork.SaveChangesAsync(cancellationToken);

                    imageUrl = url;
                    AppMetrics.RecordImageUpload(imageType: "pulse", success: true);
                }

                // 3. Create PulseEngagement for reply with zero counts
                var engagement = PulseEngagement.Create(reply.Id);
                _unitOfWork.Pulses.CreateEngagement(engagement);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                // 4. Extract and create mentions
                mentionResult = await _contentProcessor.ProcessMentionsAsync(
                    reply.Id,
                    reply.Content,
                    cancellationToken);

                // Create mention notifications (only if not mentioning self)
                foreach (var profile in mentionResult.MentionedProfiles)
                {
                    if (profile.Id != command.AuthorId)
                    {
                        var mentionNotification = Domain.Notification.Notification.CreateMentionNotification(
                            recipientId: profile.Id,
                            actorId: command.AuthorId,
                            pulseId: reply.Id);
                        _unitOfWork.Notifications.Create(mentionNotification);
                        AppMetrics.RecordNotificationCreated("mention");
                    }
                }
                if (mentionResult.MentionedProfiles.Count > 0)
                {
                    await _unitOfWork.SaveChangesAsync(cancellationToken);
                }

                // 5. Extract and process hashtags
                hashtagCount = await _contentProcessor.ProcessHashtagsAsync(
                    reply.Id,
                    reply.Content,
                    cancellationToken);

                // 6. Increment thread root's reply count (so total is shown on original pulse)
                var threadRootEngagement = await _unitOfWork.Pulses.FindEngagementAsync(
                    threadRootId,
                    cancellationToken);
                // Thread root engagement is guaranteed to exist (created with pulse)
                threadRootEngagement!.IncrementReplyCount();
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                // 7. Create reply notification (only if not replying to own pulse)
                // parentPulse was already fetched above to determine thread root
                if (parentPulse.AuthorId != command.AuthorId)
                {
                    var replyNotification = Domain.Notification.Notification.CreateReplyNotification(
                        recipientId: parentPulse.AuthorId,
                        actorId: command.AuthorId,
                        pulseId: reply.Id);
                    _unitOfWork.Notifications.Create(replyNotification);
                    await _unitOfWork.SaveChangesAsync(cancellationToken);
                    AppMetrics.RecordNotificationCreated("reply");
                }

                // Commit transaction - all entities created successfully
                // Database state is now consistent: Reply + Engagement + (optional) Image + (optional) Mentions + Parent reply count incremented
                await transaction.CommitAsync(cancellationToken);
            }
            catch
            {
                // Rollback on any error - no database records will be persisted
                await transaction.RollbackAsync(cancellationToken);

                // Clean up orphaned blob if it was uploaded but transaction failed
                // This prevents accumulating orphaned blobs in storage
                if (imageUrl is not null)
                {
                    try
                    {
                        await _blobStorageService.DeletePulseImageAsync(reply.Id, cancellationToken);
                    }
                    catch
                    {
                        // Log but don't throw - cleanup is best effort
                        // The orphaned blob can be cleaned up by a background job if needed
                    }
                }

                throw;
            }

            // Record metrics
            AppMetrics.RecordPulseReply();
            AppMetrics.RecordPulseCreated(pulseType: "reply", hasImage: hasImage);
            activity?.SetPulseMetadata(
                pulseType: "reply",
                hasImage: hasImage,
                hasLink: false,
                mentionCount: mentionResult.Count,
                hashtagCount: hashtagCount);
            activity?.SetSuccess(true);

            return new CreatePulseResult(
                PulseId: reply.Id,
                Content: reply.Content,
                CreatedAt: reply.CreatedAt,
                ImageUrl: imageUrl
            );
        }
        catch (Exception ex)
        {
            activity?.RecordError(ex);
            throw;
        }
    }
}
