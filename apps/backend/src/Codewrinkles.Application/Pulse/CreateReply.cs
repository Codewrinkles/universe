using System.Data;
using System.Text.RegularExpressions;
using Kommand.Abstractions;
using Codewrinkles.Application.Common.Interfaces;
using Codewrinkles.Domain.Pulse;

namespace Codewrinkles.Application.Pulse;

public sealed record CreateReplyCommand(
    Guid AuthorId,
    Guid ParentPulseId,
    string Content,
    Stream? ImageStream = null
) : ICommand<CreatePulseResult>;

public sealed class CreateReplyCommandHandler
    : ICommandHandler<CreateReplyCommand, CreatePulseResult>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IPulseImageService _pulseImageService;
    private readonly IProfileRepository _profileRepository;

    public CreateReplyCommandHandler(
        IUnitOfWork unitOfWork,
        IPulseImageService pulseImageService,
        IProfileRepository profileRepository)
    {
        _unitOfWork = unitOfWork;
        _pulseImageService = pulseImageService;
        _profileRepository = profileRepository;
    }

    public async Task<CreatePulseResult> HandleAsync(
        CreateReplyCommand command,
        CancellationToken cancellationToken)
    {
        // Create Reply entity (ID will be generated by EF Core during SaveChanges)
        var reply = Domain.Pulse.Pulse.CreateReply(
            authorId: command.AuthorId,
            content: command.Content,
            parentPulseId: command.ParentPulseId);

        string? imageUrl = null;

        // Perform all database operations atomically within a transaction
        // Isolation Level: ReadCommitted
        // - Prevents dirty reads (other transactions won't see incomplete Reply without Engagement)
        // - No unnecessary locking (we're only doing inserts and single update)
        await using var transaction = await _unitOfWork.BeginTransactionAsync(
            IsolationLevel.ReadCommitted,
            cancellationToken);
        try
        {
            // 1. Create Reply pulse
            _unitOfWork.Pulses.Create(reply);
            await _unitOfWork.SaveChangesAsync(cancellationToken);
            // Reply.Id is now available (generated by EF Core sequential GUID)

            // 2. Process and save image to disk (if provided)
            // This is a file I/O operation, not a database operation
            // If it fails, we'll rollback the transaction and clean up the file in catch block
            if (command.ImageStream is not null)
            {
                var (url, width, height) = await _pulseImageService.SavePulseImageAsync(
                    command.ImageStream,
                    reply.Id,
                    cancellationToken);

                var pulseImage = PulseImage.Create(
                    pulseId: reply.Id,
                    url: url,
                    width: width,
                    height: height);

                _unitOfWork.Pulses.CreateImage(pulseImage);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                imageUrl = url;
            }

            // 3. Create PulseEngagement for reply with zero counts
            var engagement = PulseEngagement.Create(reply.Id);
            _unitOfWork.Pulses.CreateEngagement(engagement);
            await _unitOfWork.SaveChangesAsync(cancellationToken);

            // 4. Extract and create mentions
            var mentionedHandles = ExtractMentions(reply.Content);
            if (mentionedHandles.Count > 0)
            {
                var mentionedProfiles = await _profileRepository.FindByHandlesAsync(mentionedHandles, cancellationToken);
                foreach (var profile in mentionedProfiles)
                {
                    var mention = PulseMention.Create(reply.Id, profile.Id, profile.Handle!);
                    _unitOfWork.Pulses.CreateMention(mention);
                }
                await _unitOfWork.SaveChangesAsync(cancellationToken);
            }

            // 5. Increment parent pulse's reply count
            var parentEngagement = await _unitOfWork.Pulses.FindEngagementAsync(
                command.ParentPulseId,
                cancellationToken);
            // Parent engagement is guaranteed to exist (created with pulse)
            parentEngagement!.IncrementReplyCount();
            await _unitOfWork.SaveChangesAsync(cancellationToken);

            // Commit transaction - all entities created successfully
            // Database state is now consistent: Reply + Engagement + (optional) Image + (optional) Mentions + Parent reply count incremented
            await transaction.CommitAsync(cancellationToken);
        }
        catch
        {
            // Rollback on any error - no database records will be persisted
            await transaction.RollbackAsync(cancellationToken);

            // Clean up orphaned image file if it was saved to disk
            // The file I/O isn't part of the database transaction, so we must clean up manually
            if (imageUrl is not null)
            {
                _pulseImageService.DeletePulseImage(reply.Id);
            }

            throw;
        }

        return new CreatePulseResult(
            PulseId: reply.Id,
            Content: reply.Content,
            CreatedAt: reply.CreatedAt,
            ImageUrl: imageUrl
        );
    }

    private static List<string> ExtractMentions(string content)
    {
        // Regex to match @handle (alphanumeric + underscore, 3-30 chars)
        var mentionPattern = @"@(\w{3,30})";
        var matches = Regex.Matches(content, mentionPattern);

        return matches
            .Select(m => m.Groups[1].Value.ToLowerInvariant())
            .Distinct()
            .ToList();
    }
}
