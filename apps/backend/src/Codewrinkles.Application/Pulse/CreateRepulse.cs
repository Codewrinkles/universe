using System.Data;
using System.Text.RegularExpressions;
using Kommand.Abstractions;
using Codewrinkles.Application.Common.Interfaces;
using Codewrinkles.Domain.Pulse;
using Codewrinkles.Telemetry;

namespace Codewrinkles.Application.Pulse;

public sealed record CreateRepulseCommand(
    Guid AuthorId,
    Guid RepulsedPulseId,
    string Content,
    Stream? ImageStream = null
) : ICommand<CreatePulseResult>;

public sealed class CreateRepulseCommandHandler
    : ICommandHandler<CreateRepulseCommand, CreatePulseResult>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IBlobStorageService _blobStorageService;
    private readonly IProfileRepository _profileRepository;

    public CreateRepulseCommandHandler(
        IUnitOfWork unitOfWork,
        IBlobStorageService blobStorageService,
        IProfileRepository profileRepository)
    {
        _unitOfWork = unitOfWork;
        _blobStorageService = blobStorageService;
        _profileRepository = profileRepository;
    }

    public async Task<CreatePulseResult> HandleAsync(
        CreateRepulseCommand command,
        CancellationToken cancellationToken)
    {
        using var activity = TelemetryExtensions.StartApplicationActivity(SpanNames.Pulse.Repulse);
        activity?.SetProfileId(command.AuthorId);
        activity?.SetTag(TagNames.Pulse.ParentPulseId, command.RepulsedPulseId.ToString());

        try
        {
            // Create Repulse entity (ID will be generated by EF Core during SaveChanges)
            var repulse = Domain.Pulse.Pulse.CreateRepulse(
                authorId: command.AuthorId,
                content: command.Content,
                repulsedPulseId: command.RepulsedPulseId);

            string? imageUrl = null;
            var hasImage = command.ImageStream is not null;

            // Perform all database operations atomically within a transaction
            // Isolation Level: ReadCommitted
            // - Prevents dirty reads (other transactions won't see incomplete Repulse without Engagement)
            // - No unnecessary locking (we're only doing inserts and single update)
            await using var transaction = await _unitOfWork.BeginTransactionAsync(
                IsolationLevel.ReadCommitted,
                cancellationToken);
            try
            {
            // 1. Create Repulse pulse
            _unitOfWork.Pulses.Create(repulse);
            await _unitOfWork.SaveChangesAsync(cancellationToken);
            // Repulse.Id is now available (generated by EF Core sequential GUID)

            // 2. Process and save image to blob storage (if provided)
            // Upload to Azure Blob Storage - if it fails, we'll rollback and clean up the blob
            if (command.ImageStream is not null)
            {
                var (url, width, height) = await _blobStorageService.UploadPulseImageAsync(
                    command.ImageStream,
                    repulse.Id,
                    cancellationToken);

                var pulseImage = PulseImage.Create(
                    pulseId: repulse.Id,
                    url: url,
                    width: width,
                    height: height);

                _unitOfWork.Pulses.CreateImage(pulseImage);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                imageUrl = url;
            }

            // 3. Create PulseEngagement for repulse with zero counts
            var engagement = PulseEngagement.Create(repulse.Id);
            _unitOfWork.Pulses.CreateEngagement(engagement);
            await _unitOfWork.SaveChangesAsync(cancellationToken);

            // 4. Extract and create mentions
            var mentionedHandles = ExtractMentions(repulse.Content);
            if (mentionedHandles.Count > 0)
            {
                var mentionedProfiles = await _profileRepository.FindByHandlesAsync(mentionedHandles, cancellationToken);
                foreach (var profile in mentionedProfiles)
                {
                    var mention = PulseMention.Create(repulse.Id, profile.Id, profile.Handle!);
                    _unitOfWork.Pulses.CreateMention(mention);

                    // Create mention notification (only if not mentioning self)
                    if (profile.Id != command.AuthorId)
                    {
                        var mentionNotification = Domain.Notification.Notification.CreateMentionNotification(
                            recipientId: profile.Id,
                            actorId: command.AuthorId,
                            pulseId: repulse.Id);
                        _unitOfWork.Notifications.Create(mentionNotification);
                    }
                }
                await _unitOfWork.SaveChangesAsync(cancellationToken);
            }

            // 5. Increment repulsed pulse's repulse count
            var repulsedEngagement = await _unitOfWork.Pulses.FindEngagementAsync(
                command.RepulsedPulseId,
                cancellationToken);
            // Repulsed engagement is guaranteed to exist (created with pulse)
            repulsedEngagement!.IncrementRepulseCount();
            await _unitOfWork.SaveChangesAsync(cancellationToken);

            // 6. Create repulse notification (only if not repulsing own pulse)
            var repulsedPulse = await _unitOfWork.Pulses.FindByIdAsync(command.RepulsedPulseId, cancellationToken);
            if (repulsedPulse is not null && repulsedPulse.AuthorId != command.AuthorId)
            {
                var repulseNotification = Domain.Notification.Notification.CreateRepulseNotification(
                    recipientId: repulsedPulse.AuthorId,
                    actorId: command.AuthorId,
                    pulseId: repulse.Id);
                _unitOfWork.Notifications.Create(repulseNotification);
                await _unitOfWork.SaveChangesAsync(cancellationToken);
            }

            // Commit transaction - all entities created successfully
                // Database state is now consistent: Repulse + Engagement + (optional) Image + (optional) Mentions + Repulsed pulse count incremented
                await transaction.CommitAsync(cancellationToken);
            }
            catch
            {
                // Rollback on any error - no database records will be persisted
                await transaction.RollbackAsync(cancellationToken);

                // Clean up orphaned blob if it was uploaded but transaction failed
                // This prevents accumulating orphaned blobs in storage
                if (imageUrl is not null)
                {
                    try
                    {
                        await _blobStorageService.DeletePulseImageAsync(repulse.Id, cancellationToken);
                    }
                    catch
                    {
                        // Log but don't throw - cleanup is best effort
                        // The orphaned blob can be cleaned up by a background job if needed
                    }
                }

                throw;
            }

            // Record metrics
            AppMetrics.RecordPulseRepulse();
            AppMetrics.RecordPulseCreated(pulseType: "repulse", hasImage: hasImage);
            if (hasImage)
            {
                AppMetrics.RecordImageUpload(imageType: "pulse", success: true);
            }
            activity?.SetEntity("Pulse", repulse.Id);
            activity?.SetPulseMetadata(pulseType: "repulse", hasImage: hasImage, hasLink: false);
            activity?.SetSuccess(true);

            return new CreatePulseResult(
                PulseId: repulse.Id,
                Content: repulse.Content,
                CreatedAt: repulse.CreatedAt,
                ImageUrl: imageUrl
            );
        }
        catch (Exception ex)
        {
            activity?.RecordError(ex);
            throw;
        }
    }

    private static List<string> ExtractMentions(string content)
    {
        // Regex to match @handle (alphanumeric + underscore, 3-30 chars)
        var mentionPattern = @"@(\w{3,30})";
        var matches = Regex.Matches(content, mentionPattern);

        return matches
            .Select(m => m.Groups[1].Value.ToLowerInvariant())
            .Distinct()
            .ToList();
    }
}
