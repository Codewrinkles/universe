using Codewrinkles.Domain.Identity;

namespace Codewrinkles.Domain.Nova;

/// <summary>
/// Represents a memory extracted from a conversation.
/// Memories help Cody remember context about the learner across conversations.
/// </summary>
public sealed class Memory
{
    // Constants
    public const int MaxContentLength = 1000;
    public const int DefaultImportance = 3;
    public const int MinImportance = 1;
    public const int MaxImportance = 5;

    // Private parameterless constructor for EF Core materialization only
    // EF Core will populate all properties via reflection when loading from database
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
    private Memory() { }
#pragma warning restore CS8618

    // Properties
    public Guid Id { get; private set; }
    public Guid ProfileId { get; private set; }
    public Guid SourceSessionId { get; private set; }
    public MemoryCategory Category { get; private set; }
    public string Content { get; private set; }
    public byte[]? Embedding { get; private set; }
    public int Importance { get; private set; }
    public int OccurrenceCount { get; private set; }
    public DateTimeOffset CreatedAt { get; private set; }
    public DateTimeOffset? SupersededAt { get; private set; }
    public Guid? SupersededById { get; private set; }

    // Navigation properties
    public Profile Profile { get; private set; }
    public ConversationSession SourceSession { get; private set; }
    public Memory? SupersededBy { get; private set; }

    // Factory method
    public static Memory Create(
        Guid profileId,
        Guid sourceSessionId,
        MemoryCategory category,
        string content,
        byte[]? embedding = null,
        int importance = DefaultImportance)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(content);

        if (importance < MinImportance || importance > MaxImportance)
        {
            throw new ArgumentOutOfRangeException(
                nameof(importance),
                $"Importance must be between {MinImportance} and {MaxImportance}.");
        }

        var trimmedContent = content.Trim();
        if (trimmedContent.Length > MaxContentLength)
        {
            trimmedContent = trimmedContent[..MaxContentLength];
        }

        return new Memory
        {
            // Id will be generated by EF Core using sequential GUID generation
            ProfileId = profileId,
            SourceSessionId = sourceSessionId,
            Category = category,
            Content = trimmedContent,
            Embedding = embedding,
            Importance = importance,
            OccurrenceCount = 1,
            CreatedAt = DateTimeOffset.UtcNow,
            SupersededAt = null,
            SupersededById = null
        };
    }

    // Public methods

    /// <summary>
    /// Marks this memory as superseded by a newer memory.
    /// </summary>
    public void Supersede(Guid newMemoryId)
    {
        SupersededAt = DateTimeOffset.UtcNow;
        SupersededById = newMemoryId;
    }

    /// <summary>
    /// Increments the occurrence count when this pattern is seen again.
    /// </summary>
    public void IncrementOccurrence()
    {
        OccurrenceCount++;
    }

    /// <summary>
    /// Updates the embedding vector for semantic search.
    /// </summary>
    public void UpdateEmbedding(byte[] embedding)
    {
        ArgumentNullException.ThrowIfNull(embedding);
        Embedding = embedding;
    }

    /// <summary>
    /// Updates the importance level.
    /// </summary>
    public void UpdateImportance(int importance)
    {
        if (importance < MinImportance || importance > MaxImportance)
        {
            throw new ArgumentOutOfRangeException(
                nameof(importance),
                $"Importance must be between {MinImportance} and {MaxImportance}.");
        }

        Importance = importance;
    }

    /// <summary>
    /// Checks if this memory is active (not superseded).
    /// </summary>
    public bool IsActive => SupersededAt is null;

    /// <summary>
    /// Returns true if this category allows only one active memory.
    /// Single-cardinality categories replace existing memories when a new one is created.
    /// </summary>
    public static bool IsSingleCardinality(MemoryCategory category)
    {
        return category is MemoryCategory.CurrentFocus or MemoryCategory.PreferredExamples;
    }
}
