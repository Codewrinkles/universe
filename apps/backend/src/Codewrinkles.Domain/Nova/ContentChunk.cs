namespace Codewrinkles.Domain.Nova;

/// <summary>
/// Represents a chunk of content from an external source for RAG.
/// </summary>
public sealed class ContentChunk
{
    // Constants
    public const int MaxTitleLength = 500;
    public const int MaxContentLength = 8000;  // ~2000 tokens
    public const int MaxSourceIdentifierLength = 1000;
    public const int MaxAuthorLength = 200;
    public const int MaxTechnologyLength = 50;
    public const int MaxParentDocumentIdLength = 500;
    public const int MaxSectionPathLength = 500;

    // Private parameterless constructor for EF Core materialization only
    // EF Core will populate all properties via reflection when loading from database
#pragma warning disable CS8618
    private ContentChunk() { }
#pragma warning restore CS8618

    // Properties
    public Guid Id { get; private set; }
    public ContentSource Source { get; private set; }
    public string SourceIdentifier { get; private set; }  // URL, video ID, book title
    public string Title { get; private set; }
    public string Content { get; private set; }
    public byte[] Embedding { get; private set; }
    public int TokenCount { get; private set; }
    public DateTimeOffset CreatedAt { get; private set; }
    public DateTimeOffset? UpdatedAt { get; private set; }

    // Optional metadata
    public string? Author { get; private set; }
    public string? Technology { get; private set; }  // "dotnet", "react", etc.
    public int? ChunkIndex { get; private set; }     // For multi-chunk documents
    public string? ParentDocumentId { get; private set; }  // Group chunks from same source
    public DateTimeOffset? PublishedAt { get; private set; }  // For freshness ranking
    public TimeSpan? StartTime { get; private set; }  // For video/audio sources
    public TimeSpan? EndTime { get; private set; }    // For video/audio sources
    public string? SectionPath { get; private set; }  // "DDD > Aggregates > Design Rules"

    // Factory method
    public static ContentChunk Create(
        ContentSource source,
        string sourceIdentifier,
        string title,
        string content,
        byte[] embedding,
        int tokenCount,
        string? author = null,
        string? technology = null,
        int? chunkIndex = null,
        string? parentDocumentId = null,
        DateTimeOffset? publishedAt = null,
        TimeSpan? startTime = null,
        TimeSpan? endTime = null,
        string? sectionPath = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceIdentifier);
        ArgumentException.ThrowIfNullOrWhiteSpace(title);
        ArgumentException.ThrowIfNullOrWhiteSpace(content);
        ArgumentNullException.ThrowIfNull(embedding);

        return new ContentChunk
        {
            // Id will be generated by EF Core using sequential GUID generation
            Source = source,
            SourceIdentifier = Truncate(sourceIdentifier.Trim(), MaxSourceIdentifierLength),
            Title = Truncate(title.Trim(), MaxTitleLength),
            Content = Truncate(content.Trim(), MaxContentLength),
            Embedding = embedding,
            TokenCount = tokenCount,
            Author = author?.Trim(),
            Technology = technology?.Trim().ToLowerInvariant(),
            ChunkIndex = chunkIndex,
            ParentDocumentId = parentDocumentId,
            PublishedAt = publishedAt,
            StartTime = startTime,
            EndTime = endTime,
            SectionPath = sectionPath,
            CreatedAt = DateTimeOffset.UtcNow
        };
    }

    // Public methods

    /// <summary>
    /// Updates the content and embedding for this chunk.
    /// </summary>
    public void UpdateContent(string content, byte[] embedding, int tokenCount)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(content);
        ArgumentNullException.ThrowIfNull(embedding);

        Content = Truncate(content.Trim(), MaxContentLength);
        Embedding = embedding;
        TokenCount = tokenCount;
        UpdatedAt = DateTimeOffset.UtcNow;
    }

    // Private helper methods
    private static string Truncate(string value, int maxLength)
    {
        return value.Length <= maxLength ? value : value[..maxLength];
    }
}
